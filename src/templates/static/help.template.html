<h1>Manual</h1>
<h3>Key features</h3>
<div class='alert alert-neutral'>
	<ul>
		<li>Easy and comfortable to use</li>
		<li>Accessible from anywhere via Web</li>
		<li>Server part highly compatible with common web hosting set-ups</li>
		<li>Agent part completely unattended</li>
		<li>File management for word lists, rules, ...</li>
		<li>Self-updating of both Hashtopussy and Hashcat</li>
		<li>Cracking multiple hashlists of the same type as one</li>
		<li>Running the same binary on Windows and Linux (OSX untested)</li>
		<li>Files/hashes marked as "secret" only distributed to agents marked as "trusted"</li>
		<li>Many options to import/export data</li>
		<li>A lot of statistic info about tasks/hashes</li>
		<li>Visual representation of chunk distribution</li>
		<li>Waiting for idle (Windows only)</li>
		<li>Event-driven cracking mode</li>
		<li>Multi-User Support</li>
		<li>User Permission levels</li>
	</ul>
</div>
<h3>Hashtopus or Hashtopussy?</h3>
<div class='alert alert-neutral'>
	Hashtopus is a great program but lacking in some areas major differences between the two are:
        <br>
	<ul>
		<li>Drastically Improved Security</li>
		<li>Multi User support</li>
		<li>Improved look and layout</li>
		<li>Super Tasks (hcmask support)</li>
		<li>--hex-salt support</li>
	</ul>
</div>
<h3>Architecture concept</h3>
<div class='alert alert-neutral'>
	Hashtopussy is a multi platform client-server tool to distribute Hashcat tasks between multiple computers and is strongly based on Hashtopus.
	<br>
	Like Hashtopus The main goals for its development were portability, robustness, Multi-user support, and to bring Hashtopus to the next level. 
	<br>
	The application has two parts:
	<ul>
		<li><b>Agent</b> Multiple clients (C#, Python, PHP) easily customizable to suite any need.
		<br></li>
		<li><b>Server</b> several PHP/CSS files operating on two endpoints: Admin
			Gui and Agent Connection Point</li>
	</ul>
	Aiming for high usability even on restricted networks, Hashtopussy communicates over HTTP(S) using own proprietary JSON protocol so its easy to understand and text-readable.
	<br>
</div>
<h3>Usage concept</h3>
<div class='alert alert-neutral'>
	The server part runs on PHP using MySQL as database back end. It is vital that your <b>MySQL server is configured as well as possible</b> performance wise. 
	<br>
 	Some of the queries can be very expensive and proper configuration makes the difference between few milliseconds of waiting and	disaster multi-second lags.
	<br>
	 The database schema heavily profits from indexing. Therefore, if you see a hint about pre-sorting your hashlist, please do so.
	<br>
	The web admin is therefore the single point of access once your agents were deployed on the cracking machines.
	<br>
	 New agent deployment requires one-time password generated in the new agent tab, which protects your server from hashes/files leaking to rogue or fake agents.
</div>
<h3>Terminology</h3>
<div class='alert alert-neutral'>
	In this manual and in the Hashtopussy itself, I use several terms. So let's make them clear:
	<ul>
	<b>Agent:</b> A computer running Hashtopussy.exe and Hashcat doing the cracking itself.
	<br>
	<b>Hashlist:</b> A list of hashes saved in the database. Hashlist can be TEXT, HCCAP or BINARY with most hashlists being the first category.
	<br>
	<b>Task:</b> A specific attack. Every task has a command line defining how will Hashcat be executed. Files can be assigned to a task (wordlists, rules,...).
	<br>
	<b>Key space:</b> Every task has a predefined key space which says precisely how big set of keys will be searched.
	<br>
	<b>Chunk:</b> A chunk is a part of a key-space assigned to a specific agent. If a chunk times out, it (or its part) will be reassigned to next free agent.
	</ul>
</div>
<hr>
<h1>First steps</h1>
<h3>Prerequisites</h3>
<div class='alert alert-neutral'>
	<b>Server</b><br>
	<ul>
		<li>Web server (Apache 2 recommended)</li>
		<li>PHP module (PHP 5.3+) with r/w access for the web directory</li>
		<li>php5-mcrypt</li>
		<li>MySQL 5.x with r/w access for the web directory</li>
		<li>MySQL user with all privileges for used database and global FILE privilege</li>
		<li>Make sure apparmor is allowing MySQL FILE permissions</li>
	</ul><br>
	<b>Agent</b><br>
	<ul>
		<li><b>This section will need an entire change when agents are coded and working</b></li>
		<li><b>.NET 2.0 compatible environment (MS .NET 2.0 or Mono 2.0)</b> On
		debian-based systems, use</li>
		<li>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
		echo "deb http://download.mono-project.com/repo/debian wheezy main" </li> 
		<li>sudo tee /etc/apt/sources.list.d/mono-xamarin.list</li>
		<li>sudo apt-get update</li>
		<li><b>apt-get install mono-complete ca-certificates-mono</b> to install desired runtime
		environment.</li>
		<li><b>Sufficient GPU drivers (see Hashcat website)</b></li>
		<li><b>HTTPS connectivity to server</b></li>
	</ul>
</div>
<h3>Installation</h3>
<div class='alert alert-neutral'>
	If you meet all prerequisites, let's start with server installation.
	<li>Unpack the entire installation package to your web-accessible directory.</li>
	<li>Create a MySQL database and a MySQL user.</li>
	<li>Assign this user all access rights to the new database and a global FILE privilege. <b>(This is very
	important for ability to import and export hashes.)</b></li>
	<li>Doing just that, the environment should be ready to use.</li> 
	<li>Now open your web-root from a web browser.</li>
	<li>Follow the install script</li>
</div>
<h3>Initial configuration</h3>
<div class='alert alert-neutral'>
	Adjust the configuration variables to your need:
	<ul>
		<li><b>Agenttimeout</b> - How long will agent ask for work if there was none last time Default:30</li>
		<li><b>Benchtime</b> - How long should hashcat benchmark each agent in (seconds) Default:30</li>
		<li><b>Chunktime</b> - Default chunk time how long should each chunk take to complete in (seconds) Default:600</li>
		<li><b>Chunktimeout</b> - How long does the chunk need to be inactive, before considered timed out in (seconds) Default:30</li>
		<li><b>Emailaddr</b> - Email to send Notifications to Default:0</li>
		<li><b>Emailerror</b> - Email agent errors to the set email address Default:0</li>
		<li><b>Emailhldone</b> - Email when a hashlist is completed Default:0</li>
		<li><b>Emailtaskdone</b> - Email when a tasks is completed Default:0</li>
		<li><b>Fieldseparator</b> - Default field separator for data import/export Default:":"</li>
		<li><b>HashlistAlias</b> - Identifier used to tell the client the name and location of the hashlist. Default:#HL#</li>
		<li><b>Statustimer</b> - How often should agent report its status during cracking in (seconds) Default:5</li>
		<li><b>Timefmt</b> - Date/time format to display in admin (see PHP function date() for this)</li>
	</ul>
</div>
<h3>Users</h3>
<div class='alert alert-neutral'>
	<li>One of the largest differences between hashtopus and hashtopussy is user accounts. These accounts allow you to set user privileges to specific users.</li>
	<ul>
		<li>View user (1): This user can only see their own account information and Tasks this includes task progress and number of cracks. They cannot see plain text password cracks or any other information.</li>
		<li>Read only user (5): Has the same permissions as lower users (1) plus they can see Hashlists, Superhashlists, Tasks, Chunk Activity and Llain text password cracks</li>
		<li>Normal User (20): Has the same permissions as lower users (1,5) plus access to Agent Data, Files, Hashcat Releases. User can Create Tasks, Preconf Tasks, Supertasks, Hashlists, and Superhashlists.  User cannot create Agents, Hashcat Releases, Modify agents they do not own, or Create other users</li>
		<li>Superuser (30): Has read/write on everything except creating other users or modifying user accounts</li>
		<li>Admin (50): All hail our dark lord and master!</li>
	</ul>
</div>
<h3>Pre-configured tasks</h3>
<div class='alert alert-neutral'>
	As you might have noticed, you often apply the same kinds of attacks against every hashlist you acquire
	<br>It would be a waste of time to create tasks every time. That's why Hashtopussy has Pre-Configured tasks
	<br>Pre-Configured tasks look like normal tasks but they are not directly attached to any hashlist
	<br>Once you upload a new hashlist, you can select which of the Pre-Configured tasks you want to apply to it
	<br>Hashtopussy will then duplicate those tasks for that specific hashlist and execute them in the defined priority
</div>
<hr>
<h1>Features documentation</h1>
<div class='alert alert-neutral'>
</div>
<h3>Server configuration</h3>
<div class='alert alert-neutral'>
Allows you to set configuration values for your server.
<br>You also have a set of DB-cleaning tools in case you get yourself into some inconsistency trouble.
</div>
<h3>Hashcat releases</h3>
<div class='alert alert-neutral'>
        Hashtopussy employs distribution mechanism to ensure that every agent will have the newest possible Hashcat release
        <br>This section contains list of defined Hashcat releases.
        <br>The installation SQL script comes with a pre-configured release pointing to the current version at the time of release, but as newer versions will be released, you will need to add them to your releases.
	<br>Common files contains list of files required for hashcat to function these files will be extracted on every agent.
	<br>Root directory is simply the name of the Root directory inside the archive.
	<br>If a release is still used by some agent, you won't be allowed to delete it.
</div>
<h3>New release</h3>
<div class='alert alert-neutral'>
	As the name suggests, this is the place to define new Hashcat releases.
	<br>Every time you open this form, it will be pre-filled by the data of the last release.
	<br>The URL has to be absolute. All files are separated by a new line.
</div>
<h3>Global files</h3>
<div class='alert alert-neutral'>
	Think of this as a file server. Every word list and rule set needs to be added to this list before you can use it in your tasks. You have three ways of adding files:
	<ul>
		<li><b>URL Download</b> The file will be downloaded from the specified URL.</li>
		<li><b>HTTP upload</b> The file will be uploaded from your browser. Suitable for smaller files because default server limits are not very generous.</li>
		<li><b>Import</b> The file will be moved from directory called 'import' you can create inside the web directory. Suitable for large files, you can copy them via FTP or locally and then simply import.</li>
	</ul>
	Because these files will be delivered to every agent who needs them for their current task, you can compress them using 7Zip to save bandwidth.
	<br>
	However, you need to keep some basic rules: the file can't be in any subdirectory inside the archive and the algorithm needs to be LZMA (to be specific, it must be unpack-able by 7zr). 
	<br>
	Every time an agent will download a file ending with .7z, it will first extract it prior to starting the task.
	<br>
	You can mark any file as "Secret" using check-box in the column with a lock icon.	
	<br>
	This will allow only trusted agents to download the file.
	<br>
	Agents not marked as trusted won't even see such task to begin with.
</div>
<h3>Pre-conf tasks</h3>
<div class='alert alert-neutral'>
	There are Three types of tasks in Hashtopussy. Tasks , Supertasks, and Pre-configured Tasks.
	<br>	
	They are actually the same thing with one difference: 
	<br>
	While regular task NEEDS to be assigned to specific hashlist, a pre-configured and supertasks do not.
	<br>
	Pre-conf task and supertasks can't have any agents assigned or any chunks dispatched.
	<br>
	Unlike regular tasks, pre-configured and super tasks can be defined without having any actual hashes in the system. 
	<br>
	Once defined, you will be allowed to apply these tasks to every hashlist you upload to Hashtopussy.
	<br>
	SuperTasks are groups of pre-conf tasks lets say for example you have 10 pre-conf tasks each brute forcing 1,2,3..10 digits respectively if you have these tasks grouped together in a supertask all 10 tasks can be deployed with a single click.
	<br>
	Tasks can only be added to a supertask if they are first created as a pre-configured task
</div>
<h3>New task</h3>
<div class='alert alert-neutral'>
	In this form, you can define a new task (it can be pre-configured)
	<br>
	Every task needs to have a name it's REALLY a good idea to keep names organized once you have many of them.
	<br>
	The command line entered is not the actual final command line, it will be enriched with more parameters which is the reason you can't use them here (as the form informs you). 
	An example of command line would be: 
	<br>
	<code>-a 0 #HL# words.txt</code>, provided that you would check words.txt in the table on the right (read below).
	<br>
	Choose an existing hashlist or a pre-configured task.
	<br>
	Following are some tweaking parameters:
	<br>
	The chunk size instructs Hashtopussy, how big chunks should it dispatch to agents, time-wise.
	<br>	
	This means that more powerful agents will be given larger chunks of key-space compared to less powerful ones, but they should take about the same time. 
	<br>	
	This is achieved by benchmarking the agents prior to giving them chunks.
	<br>
	Next option is the status timer. This defines, how often should an agent report to the server during task cracking.
	<br>
	Last check box sets if Hashtopussy should adjust agent's benchmark automatically according to the last chunk.
	<br>
	This means that i.e. if the agent takes longer time than the defined chunk time, next time it will be given smaller chunk to meet the definition.
	<br>
	However, this feature should only be enabled for attacks with "stable" speed, like mask attacks.
	<br>
	If you have already uploaded something into Global files, you see another table on the right with every file in the system.
	<br>
	If you want to use any of those files for this task, check the box next to the item you wish to use.
	<br>
	7-Zip archives when added will show the file extention as ".???" hashtopus does not know the name of the file inside of the archive so you must use the file name inside the archive in the task command line.
	<br>
	Example: <code>Wordlist.7z</code> contains the file <code>Wordlist.txt</code> the command line will need to be manualy changed from <code>Wordlist.???</code> to <code>Wordlist.txt</code>
</div>
<h3>Agent deployer</h3>
<div class='alert alert-neutral'>
	On the top of the page, you see the "Download agent" link. This is the direct, non-passworded link to download the current Hashtopussy agent.
	<br>
	Download this executable on all machines intended for cracking hashes.
	<br>
	Once executed, the agent will ask for registration voucher. That's what is the form on the page for.
	<br>
	You can generate as many vouchers as you want.
	<br>
	These vouchers are one-time tickets to allow agent registration.
	<br>
	Once the registration is successful, the agent will receive a connection token and will never ask for a password unless you delete that token or delete the agent from the administration panel.
</div>
<h3>Agents</h3>
<div class='alert alert-neutral'>
	Assuming you have your agents registered, you will see them in this list along with lots of useful information:
	<ul>
		<li><b>Act</b> This little check box enabled/disables the agent. Should Hashcat error occur, agent will be deactivated automatically unless Ignore errors is enabled for it.</li>
		<li><b>Machine Name</b> This is the actual machine name.</li>
		<li><b>Owner</b> User name of the agent owner.</li>
		<li><b>OS</b> A little icon identifying Windows from Linux.</li>
		<li><b>CPU</b> Either 32 or 64 bit.</li>
		<li><b>GPU brand</b> Either NVidia or AMD.</li>
		<li><b>Driver</b> This tells you agent's driver version.</li>
		<li><b>GPUs</b> A shortened list of detected GPU cards. Hover mouse for full text.</li>
		<li><b>Hashcat</b> If not empty, tells you what release of hashcat has the agent downloaded.</li>
		<li><b>Last activity</b> Tells you what, when and from what IP has the agent done last.</li>
		<li><b>Assignment</b> Shows you and lets you change agent's current assignment.</li>
	</ul>
	Important thing is that agent ID and Name are click-able, which will get you to agent detail page.
	<br>
	On this page, you can see all of the information from before plus some more.
	<ul>	
		<br>
		<b>GPU Platform:</b> Set GPU platform (NV, AMD) as well as CPU only agents.
		<br>
		<b>Extra Parameters:</b> Agent Specific command line options (--force, --workload-profile or --gpu-temp-disable)
		<br>
		<b>Idle wait:</b> the time the agent will wait for user inactivity before it starts cracking
		<br>
		<b>Trust:</b> only trusted agents will be allowed to crack tasks with secret hashlist or files
		<br>	
		<b>Error ignoring:</b> the agent will not be deactivated if an error occurs.
	</ul>
</div>
<h3>Hashlists</h3>
<div class='alert alert-neutral'>
	A hashlist, as the name suggests, is a list of hashes, even if there should be only one hash in it. 
	<br>
	In this table you can see all your hashlists, along with information how many hashes there are and how many of them are cracked.
        <br>
	You can also see hash type and you have some options like deleting the hashlist or importing/exporting pre-cracked hashes.
        <br>
	This option allows easy synchronizing between multiple Hashtopussy instances or even between off-line Hashcat instance and Hashtopussy.
        <br>
	Be sure to set correct field separator in Server configuration.
	<br>
	The hashlist name and ID is click able and will get you to hashlist detail page. 
        <br>
	In there, you can see info on the Hashlist list and current tasks cracking against this hashlist.
        <br>
	Clicking on most of the hash counts will take you to view the actual hashes there.
	<br>
	Enabling Secret option will allow only trusted agents to crack the hashlist.
	<br>
	The option Generate word list will take all already cracked hashes, strip the $HEX[] format and save the file as a .txt in your Global files.
	<br>
	If you have some tasks pre-configured, you can see them in the list at the bottom.
        <br>
	Checking any of them and clicking Create button will result in duplicating the pre-conf tasks and turning the copies into regular tasks attached to this hashlist. 
        <br>
	The priority of these new tasks will be sum of the maximum priority of the regular tasks and the priority of their pre-conf originals.
</div>
<h3>New hashlist</h3>
<div class='alert alert-neutral'>
	Again, every hashlist needs to have a name (this one here is mandatory, it won't be generated if omitted).
        <br>
	Hashlist format specifies whether the hashlist is a text file with many hashes, HCCAP file with network captures or binary hashlist (used for TrueCrypt 512B headers but not limited to that size).
	<br>
	Bellow you have an option to select where to get the hashes from.
        <br>
	You are already familiar with Upload, Import and URL download from Global files section.
        <br>
	The only remaining is the Paste, which will simply show text box allowing you to copy-paste hashes in there.
	<br>
	Please note that creating text-based hashlists takes some time.
        <br>
	For multi-million hashes, that will go into minutes and that's on well configured MySQL server and sorted list.
        <br>
	If you miss-configure your MySQL server and don't sort your hashlist (that's really a MUST), you might as well end up waiting several hours.
        <br>
	This is MySQL limitation and there is really nothing I can do about it. 
        <br>
	Having FILE privilege for your MySQL user is very recommended, because Hashtopussy can then use LOAD DATA command. 
        <br>
	If it fails for whatever reason, it starts to INSERT the hashes one by one inside a transaction, which is several times slower.
        <br>
	If you are having issues with LOAD DATA from file have a look at your web-root permissions and 'apparmor' Configuration.
</div>
<h3>New superhashlist</h3>
<div class='alert alert-neutral'>
	Sometimes you find yourself in a situation where you have multiple hashlists of the same hash type.
        <br>
	Naturally, the fastest way is to merge them as one and crack all at once.
        <br>
	But what if they are from different sources and the results should never be mixed?
        <br>
	The superhashlist is the feature to solve this problem. Once you have created some hashlists, you can create a superhashlist over them and use it as a regular hashlist in your tasks. 
        <br>
	However, the cracks will be kept in the original hashlists, so you will see exactly which plain text belongs where. 
        <br>
	Should one hash be contained in more hashlists, it will be cracked in all of them at once.
	<br>
	However, if any of the contained hashlists is marked as secret, hashes from this hashlist will not be given to untrusted agents to crack.
        <br>
	Should the superhashlist itself be marked as secret, no task cracking this superhashlist will be given to untrusted agent in the first place.
</div>
<h3>Tasks</h3>
<div class='alert alert-neutral'>
	Let's assume you have created a hashlist and either assigned a bunch of pre-conf tasks to it or simply created new tasks from scratch, just for this hashlist.
	You can see them in this very list. The information shown to you are:
	<ul>
		<li><b>Name</b> Name of the task that you specified or that was generated (hover mouse to get task command line pop-up).</li>
		<li><b>Hashlist</b> Name of the (super)hashlist the task is cracking.</li>
		<li><b>Chunks</b> Number of dispatched chunks and how long are they configured to take.</li>
		<li><b>Dispatched</b> How much of key space was cut into existing chunks.</li>
		<li><b>Searched</b> How much of key space was actually searched in these chunks.</li>
		<li><b>Cracked</b> How many hashes were cracked in this task. If clicked, will take you to the actual list of those hashes.</li>
		<li><b>Agents</b> Number of agents currently assigned to this task.</li>
		<li><b>Files</b> Number of global files attached to this task.</li>
		<li><b>Priority</b> Here you can see or change the priority of each task.
		<ul>
			Tasks with the highest priority are crackedfirst. 
			<br>	
			If you have an agent assigned to a task and you prioritize a new task over the current one, as soon as the agents will finish their current chunk they will move to the new task.
			<br>
			To make it simple, every time an agent asks for new chunk, it will be directed to the most prioritized task.
			<br>
			A lock icon in any column marks secret data.</li>
		</ul>
		<li><b>Action</b> As in every page, an option to delete the task.</li>
	</ul>
	Clicking on task name will take you to task detail, which is one of the	most important screens in the system.
	<br>
	You can see all the information about the task from the task list plus estimated and spent time, and current cracking speed.
        <br>
	You can also see the full command line.
	<br>
	Notice that some options are changeable - you can redefine chunk size and after you do that, all agents' benchmarks will be recalculated to match it.
	<br>
	Under the main table is a visual representation of a task.
        <br>
	This picture shows the exact chunk spread thoughout the key space including if anything was cracked in each chunk (green filling) or if there were any problems and the chunk was trimmed (red border).
	<br>
	Below is the list of attached files (click able to detail in Global files section).
	<br>
	The table under it shows information about agents assigned to this task:
	<ul>
		<li><b>Name</b> Name of agent that will link you to agent detail.</li>
		<li><b>Benchmark</b> How big chunk will be dispatched to this agent with the ability to set auto-adjusting of this size.
		<br>If you have auto-adjusting disabled, feel free to modify this value as high performance systems require larger chunks to fully utilize all the GPU power.</li>
		<li><b>Speed</b> Current cracking speed (only on active agents)</li>
		<li><b>Key space searched</b> What part of the total key space has the agent searched.
		<li><b>Time spent</b> Also good way to reward your agents, this shows how much actual time has the agent spent on this task.</li>
		<li><b>Cracked</b> A simple number showing how many hashes has the agent cracked.</li>
		<li><b>Last activity</b> Tells you exactly when was agent's last activity on this tasks.</li>
		<li><b>Action</b> Lets you unassign the agent from this task. Keep in mindthat if it's the highest priority task, the agent will return to it just after finishing its chunk.</li>
		<li><b>Show All Assignments</b> is an option that allows you to see stats on a task without clients currently assigned. If a client spent time assigned to the task its data should be seen such as key space searched and time spent.</li>
	</ul>
</div>
<h3>Chunk activity</h3>
<div class='alert alert-neutral'>
       Last and also very informative table shows the actual chunks that were dispatched in this task. You see numerous values there:
        <ul>
                <li><b>Start</b> Where exactly in the key space does this chunk start.</li>
                <li><b>Length</b> How long the chunk is, key space-wise</li>
                <li><b>Checkpoint</b> If the agent crashed, from where would the chunk have to be restarted.</li>
                <li><b>Progress</b> Real progress in that chunk, regardless of checkpoint.</li>
                <li><b>Agent</b> Self-explanatory.</li>
                <li><b>Dispatch time</b> When was the task given to the agent.</li>
		<br>
	</ul>
		A good place to monitor overall cracking activity.
</div>
<hr>
<h1>Command line</h1>
<div class='alert alert-neutral'>
	The Hashtopussy agent (client) has several command line parameters you can use to
	alter the behaviour of the agent. Those parameters are invoked as
	standalone words without prefixes like dash, etc.
	<br>
	<ul>
		<li><b>debug</b>
		<br>Invoking this parameter will force Hashtopussy to print all Hashcat output to screen as well as invoked Hashcat command lines.
		<br>Use this if you are suspecting bad parameters passed to Hashcat or Hashcat outputting garbage.</li>
		<li><b>eventmode</b> In the Event mode, Hashtopussy won't start cracking immediately. 
		<br>Instead, it will create file event_ready and wait for you to delete it.
		<br> Once you delete it, it will start cracking and will continue to crack as long as there are unfinished tasks.
		<br> When all work is completed, Hashtopussy will create file event_idle and wait for more work again.
		<br>You can use these files to wrap your own scripts around Hashtopussy to, for example, 
		<br>use your GPU on other purposes in the meantime when there is nothing to crack.</li>
		<li><b>nocheck</b>
		<br>This parameter assumes you know what you are doing make sure you have a working environment before running nocheck
		<br>This parameter disables driver version checking and also disables hashcat downloading.
		<br>You need to manually download and extract hashcat into the hashcat directory.
		<br>This enables hashtopussy to support HC3.0 and CPU only machines if you are having issues try nocheck!
	</ul>
</div>
